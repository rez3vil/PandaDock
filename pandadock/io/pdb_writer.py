"""
Proper PDB file writing utilities for PandaDock.

This module ensures all PDB files are correctly formatted according to 
the PDB standard and can be opened in molecular visualization software.
"""

import numpy as np
from typing import List, Dict, Any, Optional, Union
from pathlib import Path
from datetime import datetime


class PDBWriter:
    """
    Utility class for writing properly formatted PDB files.
    
    Ensures compliance with PDB format standards for molecular visualization
    software like ChimeraX, PyMOL, VMD, etc.
    """
    
    @staticmethod
    def write_ligand_pose(filename: Union[str, Path], coordinates: np.ndarray,
                         ligand_name: str = "LIG", score: Optional[float] = None,
                         pose_rank: Optional[int] = None, 
                         atom_types: Optional[List[str]] = None) -> None:
        """
        Write ligand pose to PDB file with proper formatting.
        
        Args:
            filename: Output PDB filename
            coordinates: Ligand coordinates as numpy array (N, 3)
            ligand_name: Ligand name (default: "LIG")
            score: Docking score to include in remarks
            pose_rank: Pose rank to include in remarks  
            atom_types: List of atom types (default: all carbon)
        """
        coordinates = np.array(coordinates)
        if coordinates.ndim != 2 or coordinates.shape[1] != 3:
            raise ValueError("Coordinates must be a Nx3 array")
        
        # Default atom types to carbon if not provided
        if atom_types is None:
            atom_types = ['C'] * len(coordinates)
        elif len(atom_types) != len(coordinates):
            raise ValueError("Number of atom types must match number of coordinates")
        
        with open(filename, 'w') as f:
            # Header information
            f.write("HEADER    MOLECULAR DOCKING RESULT\n")
            f.write(f"TITLE     PandaDock Result - {ligand_name}\n")
            f.write(f"REMARK Generated by PandaDock on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            
            if score is not None:
                f.write(f"REMARK DOCKING SCORE: {score:.4f}\n")
            if pose_rank is not None:
                f.write(f"REMARK POSE RANK: {pose_rank}\n")
            
            # Ligand atoms
            for i, (coord, atom_type) in enumerate(zip(coordinates, atom_types)):
                x, y, z = coord
                
                # Create proper atom name with correct formatting
                atom_name = PDBWriter._format_atom_name(atom_type, i + 1)
                
                # Write HETATM record with proper PDB formatting
                f.write(
                    f"HETATM{i+1:5d} {atom_name:^4s} {ligand_name:3s} A   1    "
                    f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00 20.00           {atom_type:>2s}\n"
                )
            
            f.write("END\n")
    
    @staticmethod  
    def write_protein_ligand_complex(filename: Union[str, Path], 
                                   protein_coords: np.ndarray,
                                   ligand_coords: np.ndarray,
                                   protein_atoms: Optional[List[Dict[str, Any]]] = None,
                                   ligand_atoms: Optional[List[Dict[str, Any]]] = None,
                                   ligand_name: str = "LIG",
                                   score: Optional[float] = None) -> None:
        """
        Write protein-ligand complex to PDB file.
        
        Args:
            filename: Output PDB filename
            protein_coords: Protein coordinates (N, 3)
            ligand_coords: Ligand coordinates (M, 3)
            protein_atoms: List of protein atom info dicts
            ligand_atoms: List of ligand atom info dicts
            ligand_name: Ligand residue name
            score: Docking score to include in remarks
        """
        protein_coords = np.array(protein_coords)
        ligand_coords = np.array(ligand_coords)
        
        with open(filename, 'w') as f:
            # Header information
            f.write("HEADER    PROTEIN-LIGAND COMPLEX\n")
            f.write(f"TITLE     PandaDock Complex - {ligand_name}\n")
            f.write(f"REMARK Generated by PandaDock on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            
            if score is not None:
                f.write(f"REMARK DOCKING SCORE: {score:.4f}\n")
            
            # Write protein atoms
            for i, coord in enumerate(protein_coords):
                x, y, z = coord
                
                # Get atom information
                if protein_atoms and i < len(protein_atoms):
                    atom_info = protein_atoms[i]
                    atom_type = atom_info.get('element', 'C')
                    atom_name = atom_info.get('name', f'{atom_type}{i+1}')
                    res_name = atom_info.get('res_name', 'UNK')
                    res_num = atom_info.get('res_num', 1)
                else:
                    atom_type = 'C'
                    atom_name = f'C{i+1}'
                    res_name = 'UNK'
                    res_num = 1
                
                # Format atom name properly
                formatted_atom_name = PDBWriter._format_atom_name(atom_name, None)
                
                # Write ATOM record
                f.write(
                    f"ATOM  {i+1:5d} {formatted_atom_name:^4s} {res_name:3s} A{res_num:4d}    "
                    f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00 20.00          {atom_type:>2s}\n"
                )
            
            # Write ligand atoms
            atom_offset = len(protein_coords)
            for i, coord in enumerate(ligand_coords):
                x, y, z = coord
                atom_idx = atom_offset + i + 1
                
                # Get ligand atom information
                if ligand_atoms and i < len(ligand_atoms):
                    atom_info = ligand_atoms[i]
                    atom_type = atom_info.get('element', 'C')
                    atom_name = atom_info.get('name', f'{atom_type}{i+1}')
                else:
                    atom_type = 'C'
                    atom_name = f'C{i+1}'
                
                # Format atom name properly
                formatted_atom_name = PDBWriter._format_atom_name(atom_name, None)
                
                # Write HETATM record
                f.write(
                    f"HETATM{atom_idx:5d} {formatted_atom_name:^4s} {ligand_name:3s} B   1    "
                    f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00 20.00          {atom_type:>2s}\n"
                )
            
            f.write("END\n")
    
    @staticmethod
    def _format_atom_name(atom_name: str, atom_number: Optional[int]) -> str:
        """
        Format atom name according to PDB standards.
        
        Args:
            atom_name: Base atom name (e.g., 'C', 'N', 'CA')
            atom_number: Atom number for numbering (optional)
            
        Returns:
            Properly formatted 4-character atom name
        """
        # Handle element + number combinations
        if atom_number is not None and isinstance(atom_name, str) and len(atom_name) <= 2:
            # For simple elements, create numbered atom names
            if atom_number <= 99:
                return f"{atom_name}{atom_number:02d}"
            else:
                return f"{atom_name}{atom_number}"[:4]
        
        # Handle existing atom names
        if isinstance(atom_name, str):
            # Remove extra spaces and limit to 4 characters
            clean_name = atom_name.strip()[:4]
            return clean_name
        
        # Fallback
        return "C1"
    
    @staticmethod
    def validate_pdb_file(filename: Union[str, Path]) -> tuple[bool, str]:
        """
        Validate that a PDB file is properly formatted.
        
        Args:
            filename: PDB file to validate
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        try:
            with open(filename, 'r') as f:
                lines = f.readlines()
            
            if not lines:
                return False, "Empty file"
            
            # Check for proper record types
            has_atoms = False
            has_end = False
            
            for line in lines:
                if line.startswith(('ATOM  ', 'HETATM')):
                    has_atoms = True
                    
                    # Check line length
                    if len(line.strip()) < 54:
                        return False, f"Line too short: {line.strip()}"
                    
                    # Check coordinate fields
                    try:
                        x = float(line[30:38])
                        y = float(line[38:46]) 
                        z = float(line[46:54])
                    except ValueError:
                        return False, f"Invalid coordinates in line: {line.strip()}"
                
                elif line.startswith('END'):
                    has_end = True
            
            if not has_atoms:
                return False, "No ATOM or HETATM records found"
            
            if not has_end:
                return False, "No END record found"
            
            return True, "Valid PDB file"
            
        except Exception as e:
            return False, f"Error reading file: {str(e)}"


# Convenience functions for backward compatibility
def write_pose_pdb(filename: Union[str, Path], coordinates: np.ndarray, 
                  ligand_name: str = "LIG", score: Optional[float] = None,
                  pose_rank: Optional[int] = None) -> None:
    """Write ligand pose to PDB file (convenience function)."""
    PDBWriter.write_ligand_pose(filename, coordinates, ligand_name, score, pose_rank)


def write_complex_pdb(filename: Union[str, Path], protein_coords: np.ndarray,
                     ligand_coords: np.ndarray, ligand_name: str = "LIG",
                     score: Optional[float] = None) -> None:
    """Write protein-ligand complex to PDB file (convenience function).""" 
    PDBWriter.write_protein_ligand_complex(
        filename, protein_coords, ligand_coords, 
        ligand_name=ligand_name, score=score
    )


def validate_pdb(filename: Union[str, Path]) -> tuple[bool, str]:
    """Validate PDB file (convenience function)."""
    return PDBWriter.validate_pdb_file(filename)